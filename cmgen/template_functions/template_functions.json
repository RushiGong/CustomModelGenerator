{
    "imports": "\nimport copy\nimport warnings\nfrom symengine import exp, log, Abs, Add, And, Float, Mul, Piecewise, Pow, S, sin, StrictGreaterThan, Symbol, zoo, oo\nfrom tinydb import where\nimport pycalphad.variables as v\nfrom pycalphad.core.errors import DofError\nfrom pycalphad.core.constants import MIN_SITE_FRACTION\nfrom pycalphad.core.utils import unpack_components, get_pure_elements, wrap_symbol\nimport numpy as np\nfrom pycalphad import Model\nfrom collections import OrderedDict\n",
    "functions": [
        {
            "name": "_toop_filter",
            "content": "\n    def _toop_filter(chemical_group_dict, symmetric_species, asymmetric_species):\n    #Return a function ``f(m)`` that returns ``True`` if m is symmetric with\n    #the symmetric_species and asymmetric with the asymmetric_species.\n\n    #I.e. returns True if \"j\" is the asymmetric (Toop-like) species in the i-j-m ternary\n    def _f(species):\n        if species == symmetric_species:\n            return False\n        elif species == asymmetric_species:\n            return False\n        elif chemical_group_dict[species] == chemical_group_dict[symmetric_species] and chemical_group_dict[species] != chemical_group_dict[asymmetric_species]:\n            return True  # This chemical group should be mixed\n        else:\n            return False\n    return _f"
        },
        {
            "name": "_kohler_filter",
            "content": "\n    def _kohler_filter(chemical_group_dict, symmetric_species_1, symmetric_species_2):\n    #Return a function ``f(m)`` that returns ``True`` if m is symmetric with\n    #the symmetric_species_1 and with symmetric_species_2.\n    \n    def _f(species):\n        if species == symmetric_species_1:\n            return False\n        elif species == symmetric_species_2:\n            return False\n        elif chemical_group_dict[species] == chemical_group_dict[symmetric_species_1] and chemical_group_dict[species] == chemical_group_dict[symmetric_species_2]:\n            return True  # This chemical group should be mixed\n        else:\n            return False\n    return _f"
        },
        {
            "name": "extrapolate_temperature_bounds",
            "content": "\n    def extrapolate_temperature_bounds(cls):\n        return True"
        },
        {
            "name": "__new__",
            "content": "\n    def __new__(cls, *args, **kwargs):\n        target_cls = cls._dispatch_on(*args, **kwargs)\n        instance = object.__new__(target_cls)\n        return instance"
        },
        {
            "name": "_dispatch_on",
            "content": "\n    def _dispatch_on(cls, dbe, comps, phase_name, parameters=None):\n        phase = dbe.phases[phase_name.upper()]\n        target_cls = cls\n        if 'mqmqa' in phase.model_hints.keys():\n            from pycalphad.models.model_mqmqa import ModelMQMQA\n            target_cls = ModelMQMQA\n        return target_cls"
        },
        {
            "name": "__getnewargs_ex__",
            "content": "\n    def __getnewargs_ex__(self):\n        return ((self._dbe, self.components, self.phase_name,), {'parameters': self._parameters_arg})"
        },
        {
            "name": "__init__",
            "content": "\n    def __init__(self, dbe, comps, phase_name, parameters=None):\n        self._dbe = dbe\n        self._endmember_reference_model = None\n        self.components = set()\n        self.constituents = []\n        self.phase_name = phase_name.upper()\n        phase = dbe.phases[self.phase_name]\n        self.site_ratios = list(phase.sublattices)\n        active_species = unpack_components(dbe, comps)\n        for idx, sublattice in enumerate(phase.constituents):\n            subl_comps = set(sublattice).intersection(active_species)\n            self.components |= subl_comps\n            # Support for variable site ratios in ionic liquid model\n            if phase.model_hints.get('ionic_liquid_2SL', False):\n                if idx == 0:\n                    subl_idx = 1\n                elif idx == 1:\n                    subl_idx = 0\n                else:\n                    raise ValueError('Two-sublattice ionic liquid specified with more than two sublattices')\n                self.site_ratios[subl_idx] = Add(*[v.SiteFraction(self.phase_name, idx, spec) * abs(spec.charge) for spec in subl_comps])\n        if phase.model_hints.get('ionic_liquid_2SL', False):\n            # Special treatment of \"neutral\" vacancies in 2SL ionic liquid\n            # These are treated as having variable valence\n            for idx, sublattice in enumerate(phase.constituents):\n                subl_comps = set(sublattice).intersection(active_species)\n                if v.Species('VA') in subl_comps:\n                    if idx == 0:\n                        subl_idx = 1\n                    elif idx == 1:\n                        subl_idx = 0\n                    else:\n                        raise ValueError('Two-sublattice ionic liquid specified with more than two sublattices')\n                    self.site_ratios[subl_idx] += self.site_ratios[idx] * v.SiteFraction(self.phase_name, idx, v.Species('VA'))\n        self.site_ratios = tuple(self.site_ratios)\n\n        # Verify that this phase is still possible to build\n        is_pure_VA = set()\n        for sublattice in phase.constituents:\n            sublattice_comps = set(sublattice).intersection(self.components)\n            if len(sublattice_comps) == 0:\n                # None of the components in a sublattice are active\n                # We cannot build a model of this phase\n                raise DofError(\n                    '{0}: Sublattice {1} of {2} has no components in {3}' \\\n                    .format(self.phase_name, sublattice,\n                            phase.constituents,\n                            self.components))\n            is_pure_VA.add(sum(set(map(lambda s : getattr(s, 'number_of_atoms'),sublattice_comps))))\n            self.constituents.append(sublattice_comps)\n        if sum(is_pure_VA) == 0:\n            #The only possible component in a sublattice is vacancy\n            #We cannot build a model of this phase\n            raise DofError(\n                '{0}: Sublattices of {1} contains only VA (VACUUM) constituents' \\\n                .format(self.phase_name, phase.constituents))\n        self.components = sorted(self.components)\n        desired_active_pure_elements = [list(x.constituents.keys()) for x in self.components]\n        desired_active_pure_elements = [el.upper() for constituents in desired_active_pure_elements\n                                        for el in constituents]\n        self.pure_elements = sorted(set(desired_active_pure_elements))\n        self.nonvacant_elements = [x for x in self.pure_elements if x != 'VA']\n\n        # Convert string symbol names to Symbol objects\n        # This makes xreplace work with the symbols dict\n        symbols = {Symbol(s): val for s, val in dbe.symbols.items()}\n\n        if parameters is not None:\n            self._parameters_arg = parameters\n            if isinstance(parameters, dict):\n                symbols.update([(wrap_symbol(s), val) for s, val in parameters.items()])\n            else:\n                # Lists of symbols that should remain symbolic\n                for s in parameters:\n                    symbols.pop(wrap_symbol(s))\n        else:\n            self._parameters_arg = None\n\n        self._symbols = {wrap_symbol(key): value for key, value in symbols.items()}\n\n        self.models = OrderedDict()\n        self.build_phase(dbe)\n\n        for name, value in self.models.items():\n            # XXX: xreplace hack because SymEngine seems to let Symbols slip in somehow\n            self.models[name] = self.symbol_replace(value, symbols).xreplace(v.supported_variables_in_databases)\n\n        self.site_fractions = sorted([x for x in self.variables if isinstance(x, v.SiteFraction)], key=str)\n        self.state_variables = sorted([x for x in self.variables if not isinstance(x, v.SiteFraction)], key=str)"
        },
        {
            "name": "unwrap_piecewise",
            "content": "\n    def unwrap_piecewise(cls, graph):\n        from pycalphad.io.tdb import to_interval\n        replace_dict = {}\n        for atom in graph.atoms(Piecewise):\n            args = atom.args\n            # Unwrap temperature-dependent piecewise with zero-defaults\n            if len(args) == 4 and args[2] == 0 and args[3] == True and args[1].free_symbols == {v.T}:\n                replace_dict[atom] = args[0]\n            elif cls.extrapolate_temperature_bounds:\n                # Set lower and upper temperature limits to -+infinity\n                # First filter out default zero-branches\n                filtered_args = [(x, cond) for x, cond in zip(*[iter(args)]*2) if not ((cond == S.true) and (x == S.Zero))]\n                if len(filtered_args) == 0:\n                    continue\n                if not all([cond.free_symbols == {v.T} for _, cond in filtered_args]):\n                    # Only temperature-dependent piecewise conditions are supported for extrapolation\n                    continue\n                intervals = [to_interval(cond) for _, cond in filtered_args]\n                sortindices = [i[0] for i in sorted(enumerate(intervals), key=lambda x:x[1].args[0])]\n                if (intervals[sortindices[0]].args[0] == S.NegativeInfinity) and \\\n                   (intervals[sortindices[-1]].args[1] == S.Infinity):\n                    # Nothing to do, temperature range already extrapolated\n                    continue\n                # First branch is special-cased to negative infinity\n                exprcondpairs = [(filtered_args[sortindices[0]][0], v.T < intervals[sortindices[0]].args[1])]\n                for idx in sortindices[1:-1]:\n                    exprcondpairs.append((filtered_args[sortindices[idx]][0],\n                                         And(v.T >= intervals[sortindices[idx]].args[0], v.T < intervals[sortindices[idx]].args[1])\n                    ))\n                # Last branch is special-cased to positive infinity\n                exprcondpairs.append((filtered_args[sortindices[-1]][0],\n                                      v.T >= intervals[sortindices[-1]].args[0]\n                ))\n                # Catch-all branch required for LLVM (should never hit in this formulation)\n                exprcondpairs.append((0, True))\n                replace_dict[atom] = Piecewise(*exprcondpairs)\n        return graph.xreplace(replace_dict)"
        },
        {
            "name": "symbol_replace",
            "content": "\n    def symbol_replace(cls, obj, symbols):\n        \"\"\"\n        Substitute values of symbols into 'obj'.\n\n        Parameters\n        ----------\n        obj : SymEngine object\n        symbols : dict mapping symengine.Symbol to SymEngine object\n\n        Returns\n        -------\n        SymEngine object\n        \"\"\"\n        try:\n            # Need to do more substitutions to catch symbols that are functions\n            # of other symbols\n            for iteration in range(_MAX_PARAM_NESTING):\n                obj = obj.xreplace(symbols)\n                obj = cls.unwrap_piecewise(obj)\n                undefs = [x for x in obj.free_symbols if not isinstance(x, v.StateVariable)]\n                if len(undefs) == 0:\n                    break\n        except AttributeError:\n            # Can't use xreplace on a float\n            pass\n        return obj"
        },
        {
            "name": "__eq__",
            "content": "\n    def __eq__(self, other):\n        if self is other:\n            return True\n        elif type(self) != type(other):\n            return False\n        else:\n            return self.__dict__ == other.__dict__"
        },
        {
            "name": "__ne__",
            "content": "\n    def __ne__(self, other):\n        return not self.__eq__(other)"
        },
        {
            "name": "__hash__",
            "content": "\n    def __hash__(self):\n        return hash(repr(self))"
        },
        {
            "name": "moles",
            "content": "\n    def moles(self, species, per_formula_unit=False):\n        \"Number of moles of species or elements.\"\n        species = v.Species(species)\n        is_pure_element = (len(species.constituents.keys()) == 1 and\n                           list(species.constituents.keys())[0] == species.name)\n        result = S.Zero\n        normalization = S.Zero\n        if is_pure_element:\n            element = list(species.constituents.keys())[0]\n            for idx, sublattice in enumerate(self.constituents):\n                active = set(sublattice).intersection(self.components)\n                result += self.site_ratios[idx] * \\\n                    sum(int(spec.number_of_atoms > 0) * spec.constituents.get(element, 0) * v.SiteFraction(self.phase_name, idx, spec)\n                        for spec in active)\n                normalization += self.site_ratios[idx] * \\\n                    sum(spec.number_of_atoms * v.SiteFraction(self.phase_name, idx, spec)\n                        for spec in active)\n        else:\n            for idx, sublattice in enumerate(self.constituents):\n                active = set(sublattice).intersection({species})\n                if len(active) == 0:\n                    continue\n                result += self.site_ratios[idx] * sum(v.SiteFraction(self.phase_name, idx, spec) for spec in active)\n                normalization += self.site_ratios[idx] * \\\n                    sum(int(spec.number_of_atoms > 0) * v.SiteFraction(self.phase_name, idx, spec)\n                        for spec in active)\n        if not per_formula_unit:\n            return result / normalization\n        else:\n            return result"
        },
        {
            "name": "ast",
            "content": "\n    def ast(self):\n        \"Return the full abstract syntax tree of the model.\"\n        return Add(*list(self.models.values()))"
        },
        {
            "name": "variables",
            "content": "\n    def variables(self):\n        \"Return state variables in the model.\"\n        return sorted([x for x in self.ast.free_symbols if isinstance(x, v.StateVariable)], key=str)"
        },
        {
            "name": "degree_of_ordering",
            "content": "\n    def degree_of_ordering(self):\n        result = S.Zero\n        site_ratio_normalization = S.Zero\n        # Calculate normalization factor\n        for idx, sublattice in enumerate(self.constituents):\n            active = set(sublattice).intersection(self.components)\n            subl_content = sum(int(spec.number_of_atoms > 0) * v.SiteFraction(self.phase_name, idx, spec) for spec in active)\n            site_ratio_normalization += self.site_ratios[idx] * subl_content\n\n        site_ratios = [c/site_ratio_normalization for c in self.site_ratios]\n        for comp in self.components:\n            if comp.number_of_atoms == 0:\n                continue\n            comp_result = S.Zero\n            for idx, sublattice in enumerate(self.constituents):\n                active = set(sublattice).intersection(set(self.components))\n                if comp in active:\n                    comp_result += site_ratios[idx] * Abs(v.SiteFraction(self.phase_name, idx, comp) - self.moles(comp)) / self.moles(comp)\n            result += comp_result\n        return result / sum(int(spec.number_of_atoms > 0) for spec in self.components)"
        },
        {
            "name": "endmember_reference_model",
            "content": "\n    def endmember_reference_model(self):\n        \n        #Return a Model containing only energy contributions from endmembers.\n\n        if self._endmember_reference_model is None:\n            endmember_only_dbe = copy.deepcopy(self._dbe)\n            endmember_only_dbe._parameters.remove(where('constituent_array').test(self._interaction_test))\n            mod_endmember_only = self.__class__(endmember_only_dbe, self.components, self.phase_name, parameters=self._parameters_arg)\n            # Ideal mixing contributions are always generated, so we need to set the\n            # contribution of the endmember reference model to zero to preserve ideal\n            # mixing in this model.\n            mod_endmember_only.models['idmix'] = 0\n            if self.models.get('ord', S.Zero) != S.Zero:\n                warnings.warn(\n                    f\"{self.phase_name} is a partitioned model with an ordering energy \"\n                    \"contribution. The choice of endmembers for the endmember \"\n                    \"reference model used by `_MIX` properties is ambiguous for \"\n                    \"partitioned models. The `Model.set_reference_state` method is a \"\n                    \"better choice for computing mixing energy. See \"\n                    \"https://pycalphad.org/docs/latest/examples/ReferenceStateExamples.html \"\n                    \"for an example.\"\n                )\n                for k in mod_endmember_only.models.keys():\n                    mod_endmember_only.models[k] = float('nan')\n            self._endmember_reference_model = mod_endmember_only\n        return self._endmember_reference_model"
        },
        {
            "name": "get_internal_constraints",
            "content": "\n    def get_internal_constraints(self):\n        constraints = []\n        # Site fraction balance\n        for idx, sublattice in enumerate(self.constituents):\n            constraints.append(sum(v.SiteFraction(self.phase_name, idx, spec) for spec in sublattice) - 1)\n        # Charge balance for all phases that are charged\n        has_charge = len({sp for sp in self.components if sp.charge != 0}) > 0\n        constant_site_ratios = True\n        # The only implementation with variable site ratios is the two-sublattice ionic liquid.\n        # This check is convenient for detecting 2SL ionic liquids without keeping other state.\n        # Because 2SL ionic liquids charge balance 'automatically', we do not need to enforce charge balance.\n        for sr in self.site_ratios:\n            try:\n                float(sr)\n            except (TypeError, RuntimeError):\n                constant_site_ratios = False\n        # For all other cases where charge is present, we do need to add charge balance.\n        if constant_site_ratios and has_charge:\n            total_charge = 0\n            for idx, (sublattice, site_ratio) in enumerate(zip(self.constituents, self.site_ratios)):\n                total_charge += sum(v.SiteFraction(self.phase_name, idx, spec) * spec.charge * site_ratio\n                                    for spec in sublattice)\n            constraints.append(total_charge)\n        return constraints"
        },
        {
            "name": "build_phase",
            "content": "\n    def build_phase(self, dbe):\n\n        #Generate the symbolic form of all the contributions to this phase.\n\n        contrib_vals = list(OrderedDict(self.__class__.contributions).values())\n        if 'atomic_ordering_energy' in contrib_vals:\n            if contrib_vals.index('atomic_ordering_energy') != (len(contrib_vals) - 1):\n                # Check for a common mistake in custom models\n                # Users that need to override this behavior should override build_phase\n                raise ValueError('\\'atomic_ordering_energy\\' must be the final contribution')\n        self.models.clear()\n        for key, value in self.__class__.contributions:\n            self.models[key] = S(getattr(self, value)(dbe))"
        },
        {
            "name": "_array_validity",
            "content": "\n    def _array_validity(self, constituent_array):\n        \n        #Return True if the constituent_array contains only active species of the current Model instance.\n        \n        if len(constituent_array) != len(self.constituents):\n            # Allow an exception for the ionic liquid model, where neutral\n            # species can be specified in the anion sublattice without any\n            # species in the cation sublattice.\n            ionic_liquid_2SL = self._dbe.phases[self.phase_name].model_hints.get('ionic_liquid_2SL', False)\n            if ionic_liquid_2SL and len(constituent_array) == 1:\n                param_sublattice = constituent_array[0]\n                model_anion_sublattice = self.constituents[1]\n                if (set(param_sublattice).issubset(model_anion_sublattice) or (param_sublattice[0] == v.Species('*'))):\n                    return True\n            return False\n        for param_sublattice, model_sublattice in zip(constituent_array, self.constituents):\n            if not (set(param_sublattice).issubset(model_sublattice) or (param_sublattice[0] == v.Species('*'))):\n                return False\n        return True"
        },
        {
            "name": "_purity_test",
            "content": "\n    def _purity_test(self, constituent_array):\n        \n        #Return True if the constituent_array is valid and has exactly one\n        #species in every sublattice.\n        \n        if not self._array_validity(constituent_array):\n            return False\n        return not any(len(sublattice) != 1 for sublattice in constituent_array)"
        },
        {
            "name": "_interaction_test",
            "content": "\n    def _interaction_test(self, constituent_array):\n        \n        #Return True if the constituent_array is valid and has more than one\n        #species in at least one sublattice.\n        \n        if not self._array_validity(constituent_array):\n            return False\n        return any([len(sublattice) > 1 for sublattice in constituent_array])"
        },
        {
            "name": "_site_ratio_normalization",
            "content": "\n    def _site_ratio_normalization(self):\n        \n        #Calculates the normalization factor based on the number of sites\n        #in each sublattice.\n        \n        site_ratio_normalization = S.Zero\n        # Calculate normalization factor\n        for idx, sublattice in enumerate(self.constituents):\n            active = set(sublattice).intersection(self.components)\n            subl_content = sum(spec.number_of_atoms * v.SiteFraction(self.phase_name, idx, spec) for spec in active)\n            site_ratio_normalization += self.site_ratios[idx] * subl_content\n        return site_ratio_normalization"
        },
        {
            "name": "_Muggianu_correction_dict",
            "content": "\n    def _Muggianu_correction_dict(comps): #pylint: disable=C0103\n        \n        #Replace y_i -> y_i + (1 - sum(y involved in parameter)) / m,\n        #where m is the arity of the interaction parameter.\n        #Returns a dict converting the list of Symbols (comps) to this.\n        #m is assumed equal to the length of comps.\n\n        arity = len(comps)\n        return_dict = {}\n        correction_term = (S.One - Add(*comps)) / arity\n        for comp in comps:\n            return_dict[comp] = comp + correction_term\n        return return_dict"
        },
        {
            "name": "_Xi_ij",
            "content": "\n    def _Xi_ij(self, phase, sublattice_index, i, j):\n        # Species of the same chemical group may use a Kohler-type or\n        # Muggianu-type approximation (the choice does not affect this function).\n        # Species of different chemical groups use a Toop-type approximation.\n        toop_filter = _toop_filter(phase.model_hints['chemical_groups'], i, j)\n        toop_correction = S.Zero\n        active_subl_comps = phase.constituents[sublattice_index].intersection(self.components)\n        for k in filter(toop_filter, active_subl_comps):\n            toop_correction += v.Y(self.phase_name, sublattice_index, k)\n        return v.Y(self.phase_name, sublattice_index, i) + toop_correction"
        },
        {
            "name": "_sigma_ij",
            "content": "\n    def _sigma_ij(self, phase, sublattice_index, i, j):\n        # Compute the correction for Kohler-type approximation between species i and j\n        # We don't yet have a way to flag whether the ij interaction, if the\n        # species are of the same chemical group (they are \"symmetric\", by\n        # Pelton) uses a Kohler-type or Muggianu-type approximation. Since\n        # there exists the _Muggianu_correction_dict already, we assume that\n        # callers of this function are only interested in a Kohler-type\n        # approximation for species of the same type. Species of different\n        # chemical groups use a Toop-type approximation.\n        kohler_filter = _kohler_filter(phase.model_hints['chemical_groups'], i, j)\n        kohler_correction = S.Zero\n        active_subl_comps = phase.constituents[sublattice_index].intersection(self.components)\n        for k in filter(kohler_filter, active_subl_comps):\n            kohler_correction += v.Y(self.phase_name, sublattice_index, k)\n        return 1 -  kohler_correction"
        },
        {
            "name": "_alpha_ij_Q",
            "content": "\n    def _alpha_ij_Q(self, phase, sublattice_index, i, j, q_ij, exp_i, exp_j):\n        Xi_ij = self._Xi_ij(phase, sublattice_index, i, j)\n        Xi_ji = self._Xi_ij(phase, sublattice_index, j, i)\n        sigma_ij = self._sigma_ij(phase, sublattice_index, i, j) # same for both\n        i_term = (1 + (Xi_ij - Xi_ji) / sigma_ij) / 2\n        j_term = (1 + (Xi_ji - Xi_ij) / sigma_ij) / 2\n        return q_ij * i_term**exp_i * j_term**exp_j"
        },
        {
            "name": "_alpha_ij_L",
            "content": "\n    def _alpha_ij_L(self, phase, sublattice_index, i, j, L_ij, parameter_order):\n        # Use the parameter-sorted order for i and j, noting that L_{ij} != L_{ji} for odd-ordered terms.\n        Xi_ij = self._Xi_ij(phase, sublattice_index, i, j)\n        Xi_ji = self._Xi_ij(phase, sublattice_index, j, i)\n        sigma_ij = self._sigma_ij(phase, sublattice_index, i, j)\n        mixing_term = (Xi_ij - Xi_ji) / sigma_ij\n        return L_ij * mixing_term**parameter_order"
        },
        {
            "name": "kohler_toop_excess_sum",
            "content": "\n    def kohler_toop_excess_sum(self, dbe):\n        phase = dbe.phases[self.phase_name]\n        param_query = (\n            (where(\"phase_name\") == phase.name) &\n            (where(\"parameter_type\") == \"QKT\") &\n            (where('constituent_array').test(self._array_validity))\n        )\n        param_search = dbe.search\n\n        params = param_search(param_query)\n        kohler_toop_xs = S.Zero\n        for param in params:\n            mixing_term = S.One\n            for subl_idx, subl_comps in enumerate(param[\"constituent_array\"]):\n                mixing_term *= Mul(*[v.SiteFraction(phase.name, subl_idx, comp) for comp in subl_comps])\n                if len(subl_comps) == 2:\n                    # Note: The structure of exponents (a `List[int]`) currently assumes only one sublattice has mixing\n                    assert len(subl_comps) == len(param[\"exponents\"])\n                    i, j = subl_comps\n                    p, q = param[\"exponents\"]\n                    alpha_ij_Q = self._alpha_ij_Q(phase, subl_idx, i, j, param[\"parameter\"], p, q)\n                    mixing_term *= alpha_ij_Q\n                elif len(subl_comps) == 3:\n                    # Pelton's 2001 paper lays out several different flavors of\n                    # ternary parameters, but the simple flavor of ternary\n                    # parameters (Pelton 2001 Eq. 17) seems to be used in the\n                    # Quasichemical Kohler-Toop model implemented in DAT files.\n                    # Note: The structure of exponents (a `List[int]`) currently assumes only one sublattice has mixing\n                    exponents = param[\"exponents\"]\n                    assert len(subl_comps) == len(exponents)\n                    mixing_term *= Mul(*[v.SiteFraction(phase.name, subl_idx, comp)**expn for comp, expn in zip(subl_comps, exponents)])\n                    # Note, the following normalization is not in the paper\n                    # either, but the equation in the paper clearly states that\n                    # this type of \"simple\" ternary is discouraged and doesn't\n                    # talk about how to extrapolate into multi-component.\n                    mixing_term /= Add(*[v.SiteFraction(phase.name, subl_idx, comp) for comp in subl_comps])**(sum(exponents))\n                    mixing_term *= param[\"parameter\"]\n                else:\n                    raise ValueError(f\"Unsupported number of components are mixing, got {len(subl_comps)} ({subl_comps}), expected 2 or 3.\")\n            kohler_toop_xs += mixing_term\n        return kohler_toop_xs"
        },
        {
            "name": "redlich_kister_sum",
            "content": "\n    def redlich_kister_sum(self, phase, param_search, param_query):\n        \n        #Construct parameter in Redlich-Kister polynomial basis, using\n        #the Muggianu ternary parameter extension.\n        \n        rk_terms = []\n\n        # search for desired parameters\n        params = param_search(param_query)\n        for param in params:\n            # iterate over every sublattice\n            mixing_term = S.One\n            for subl_index, comps in enumerate(param['constituent_array']):\n                comp_symbols = None\n                # convert strings to symbols\n                if comps[0] == v.Species('*'):\n                    # Handle wildcards in constituent array\n                    comp_symbols = \\\n                        [\n                            v.SiteFraction(phase.name, subl_index, comp)\n                            for comp in sorted(set(phase.constituents[subl_index])\\\n                                .intersection(self.components))\n                        ]\n                    mixing_term *= Add(*comp_symbols)\n                else:\n                    if (\n                        phase.model_hints.get('ionic_liquid_2SL', False) and  # This is an ionic 2SL\n                        len(param['constituent_array']) == 1 and  # There's only one sublattice\n                        all(const.charge == 0 for const in param['constituent_array'][0])  # All constituents are neutral\n                    ):\n                        # The constituent array is all neutral anion species in what would be the\n                        # second sublattice. TDB syntax allows for specifying neutral species with\n                        # one sublattice model. Set the sublattice index to 1 for the purpose of\n                        # site fractions.\n                        subl_index = 1\n                    comp_symbols = \\\n                        [\n                            v.SiteFraction(phase.name, subl_index, comp)\n                            for comp in comps\n                        ]\n                    if phase.model_hints.get('ionic_liquid_2SL', False):  # This is an ionic 2SL\n                        # We need to special case sorting for this model, because the constituents\n                        # should not be alphabetically sorted. The model should be (C)(A, Va, B)\n                        # for cations (C), anions (A), vacancies (Va) and neutrals (B). Thus the\n                        # second sublattice should be sorted by species with charge, then by\n                        # vacancies, if present, then by neutrals. Hint: in Thermo-Calc, using\n                        # `set-start-constitution` for a phase will prompt you to enter site\n                        # fractions for species in the order they are sorted internally within\n                        # Thermo-Calc. This can be used to verify sorting behavior.\n\n                        # Assume that the constituent array is already in sorted order\n                        # alphabetically, so we need to rearrange the species first by charged\n                        # species, then VA, then netural species. Since the cation sublattice\n                        # should only have charged species by definition, this is equivalent to\n                        # a no-op for the first sublattice.\n                        charged_symbols = [sitefrac for sitefrac in comp_symbols if sitefrac.species.charge != 0 and sitefrac.species.number_of_atoms > 0]\n                        va_symbols = [sitefrac for sitefrac in comp_symbols if sitefrac.species == v.Species('VA')]\n                        neutral_symbols = [sitefrac for sitefrac in comp_symbols if sitefrac.species.charge == 0 and sitefrac.species.number_of_atoms > 0]\n                        comp_symbols = charged_symbols + va_symbols + neutral_symbols\n\n                    mixing_term *= Mul(*comp_symbols)\n                # is this a higher-order interaction parameter?\n                if len(comps) == 2 and param['parameter_order'] > 0:\n                    # interacting sublattice, add the interaction polynomial\n                    mixing_term *= Pow(comp_symbols[0] - \\\n                        comp_symbols[1], param['parameter_order'])\n                if len(comps) == 3:\n                    # 'parameter_order' is an index to a variable when\n                    # we are in the ternary interaction parameter case\n\n                    # NOTE: The commercial software packages seem to have\n                    # a \"feature\" where, if only the zeroth\n                    # parameter_order term of a ternary parameter is specified,\n                    # the other two terms are automatically generated in order\n                    # to make the parameter symmetric.\n                    # In other words, specifying only this parameter:\n                    # PARAMETER G(FCC_A1,AL,CR,NI;0) 298.15  +30300; 6000 N !\n                    # Actually implies:\n                    # PARAMETER G(FCC_A1,AL,CR,NI;0) 298.15  +30300; 6000 N !\n                    # PARAMETER G(FCC_A1,AL,CR,NI;1) 298.15  +30300; 6000 N !\n                    # PARAMETER G(FCC_A1,AL,CR,NI;2) 298.15  +30300; 6000 N !\n                    #\n                    # If either 1 or 2 is specified, no implicit parameters are\n                    # generated.\n                    # We need to handle this case.\n                    if param['parameter_order'] == 0:\n                        # are _any_ of the other parameter_orders specified?\n                        ternary_param_query = (\n                            (where('phase_name') == param['phase_name']) & \\\n                            (where('parameter_type') == \\\n                                param['parameter_type']) & \\\n                            (where('constituent_array') == \\\n                                param['constituent_array'])\n                        )\n                        other_tern_params = param_search(ternary_param_query)\n                        if len(other_tern_params) == 1 and \\\n                            other_tern_params[0] == param:\n                            # only the current parameter is specified\n                            # We need to generate the other two parameters.\n                            order_one = copy.copy(param)\n                            order_one['parameter_order'] = 1\n                            order_two = copy.copy(param)\n                            order_two['parameter_order'] = 2\n                            # Add these parameters to our iteration.\n                            params.extend((order_one, order_two))\n                    # Include variable indicated by parameter order index\n                    # Perform Muggianu adjustment to site fractions\n                    mixing_term *= comp_symbols[param['parameter_order']].subs(\n                        self._Muggianu_correction_dict(comp_symbols))\n            if phase.model_hints.get('ionic_liquid_2SL', False):\n                # Special normalization rules for parameters apply under this model\n                # If there are no anions present in the anion sublattice (only VA and neutral\n                # species), then the energy has an additional Q*y(VA) term\n                anions_present = any([m.species.charge < 0 for m in mixing_term.free_symbols])\n                if not anions_present:\n                    pair_rule = {}\n                    # Cation site fractions must always appear with vacancy site fractions\n                    va_subls = [(v.Species('VA') in phase.constituents[idx]) for idx in range(len(phase.constituents))]\n                    # The last index that contains a vacancy\n                    va_subl_idx = (len(phase.constituents) - 1) - va_subls[::-1].index(True)\n                    va_present = any((v.Species('VA') in c) for c in param['constituent_array'])\n                    if va_present and (max(len(c) for c in param['constituent_array']) == 1):\n                        # No need to apply pair rule for VA-containing endmember\n                        pass\n                    elif va_subl_idx > -1:\n                        for sym in mixing_term.free_symbols:\n                            if sym.species.charge > 0:\n                                pair_rule[sym] = sym * v.SiteFraction(sym.phase_name, va_subl_idx, v.Species('VA'))\n                    mixing_term = mixing_term.xreplace(pair_rule)\n                    # This parameter is normalized differently due to the variable charge valence of vacancies\n                    mixing_term *= self.site_ratios[va_subl_idx]\n            param_val = param['parameter']\n            if isinstance(param_val, Piecewise):\n                # Eliminate redundant Piecewise and extrapolate beyond temperature limits\n                filtered_args = [expr for expr, cond in zip(*[iter(param_val.args)]*2) if not ((cond == S.true) and (expr == S.Zero))]\n                if len(filtered_args) == 1:\n                    param_val = filtered_args[0]\n            rk_terms.append(mixing_term * param_val)\n        return Add(*rk_terms)"
        },
        {
            "name": "reference_energy",
            "content": "\n    def reference_energy(self, dbe):\n        \n        #Returns the weighted average of the endmember energies\n        #in symbolic form.\n        \n        pure_param_query = (\n            (where('phase_name') == self.phase_name) & \\\n            (where('parameter_order') == 0) & \\\n            (where('parameter_type') == \"G\") & \\\n            (where('constituent_array').test(self._purity_test))\n        )\n        phase = dbe.phases[self.phase_name]\n        param_search = dbe.search\n        pure_energy_term = self.redlich_kister_sum(phase, param_search,\n                                                   pure_param_query)\n        return pure_energy_term / self._site_ratio_normalization"
        },
        {
            "name": "ideal_mixing_energy",
            "content": "\n    def ideal_mixing_energy(self, dbe):\n        #pylint: disable=W0613\n        \n        #Returns the ideal mixing energy in symbolic form.\n        \n        phase = dbe.phases[self.phase_name]\n        site_ratios = self.site_ratios\n        ideal_mixing_term = S.Zero\n        sitefrac_limit = Float(MIN_SITE_FRACTION/10.)\n        for subl_index, sublattice in enumerate(phase.constituents):\n            active_comps = set(sublattice).intersection(self.components)\n            ratio = site_ratios[subl_index]\n            for comp in active_comps:\n                sitefrac = \\\n                    v.SiteFraction(phase.name, subl_index, comp)\n                # We lose some precision here, but this makes the limit behave nicely\n                # We're okay until fractions of about 1e-12 (platform-dependent)\n                mixing_term = Piecewise((sitefrac*log(sitefrac),\n                                         StrictGreaterThan(sitefrac, sitefrac_limit)), (0, True),\n                                        )\n                ideal_mixing_term += (mixing_term*ratio)\n        ideal_mixing_term *= (v.R * v.T)\n        return ideal_mixing_term / self._site_ratio_normalization"
        },
        {
            "name": "excess_mixing_energy",
            "content": "\n    def excess_mixing_energy(self, dbe):\n        \n        #Build the binary, ternary and higher order interaction term\n        #Here we use Redlich-Kister polynomial basis by default\n        #Here we use the Muggianu ternary extension by default\n        #Replace y_i -> y_i + (1 - sum(y involved in parameter)) / m,\n        #where m is the arity of the interaction parameter\n        \n        phase = dbe.phases[self.phase_name]\n        param_search = dbe.search\n        param_query = (\n            (where('phase_name') == self.phase_name) & \\\n                ((where('parameter_type') == 'G') |\n                 (where('parameter_type') == 'L')) & \\\n                (where('constituent_array').test(self._interaction_test))\n            )\n        excess_term = self.redlich_kister_sum(phase, param_search, param_query)\n        excess_term += self.kohler_toop_excess_sum(dbe)\n        return excess_term / self._site_ratio_normalization"
        },
        {
            "name": "magnetic_energy",
            "content": "\n    def magnetic_energy(self, dbe):\n        #pylint: disable=C0103, R0914\n        \n        #Return the energy from magnetic ordering in symbolic form.\n        #The implemented model is the Inden-Hillert-Jarl formulation.\n        #The approach follows from the background of W. Xiong et al, Calphad, 2012.\n        \n        phase = dbe.phases[self.phase_name]\n        param_search = dbe.search\n        self.TC = self.curie_temperature = S.Zero\n        self.BMAG = self.beta = S.Zero\n        if 'ihj_magnetic_structure_factor' not in phase.model_hints:\n            return S.Zero\n        if 'ihj_magnetic_afm_factor' not in phase.model_hints:\n            return S.Zero\n\n        site_ratio_normalization = self._site_ratio_normalization\n        # define basic variables\n        afm_factor = phase.model_hints['ihj_magnetic_afm_factor']\n\n        if afm_factor == 0:\n            # Apply improved magnetic model which does not use AFM / Weiss factor\n            return self.xiong_magnetic_energy(dbe)\n\n        bm_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'BMAGN') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n        tc_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'TC') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n\n        mean_magnetic_moment = \\\n            self.redlich_kister_sum(phase, param_search, bm_param_query)\n        beta = mean_magnetic_moment / Piecewise(\n            (afm_factor, mean_magnetic_moment <= 0),\n            (1., True)\n            )\n        self.BMAG = self.beta = self.symbol_replace(beta, self._symbols)\n\n        curie_temp = \\\n            self.redlich_kister_sum(phase, param_search, tc_param_query)\n        tc = curie_temp / Piecewise(\n            (afm_factor, curie_temp <= 0),\n            (1., True)\n            )\n        self.TC = self.curie_temperature = self.symbol_replace(tc, self._symbols)\n\n        # Used to prevent singularity\n        tau_positive_tc = v.T / (curie_temp + 1e-9)\n        tau_negative_tc = v.T / ((curie_temp/afm_factor) + 1e-9)\n\n        # define model parameters\n        p = phase.model_hints['ihj_magnetic_structure_factor']\n        A = 518/1125 + (11692/15975)*(1/p - 1)\n        # factor when tau < 1 and tc < 0\n        sub_tau_neg_tc = 1 - (1/A) * ((79/(140*p))*(tau_negative_tc**(-1)) + (474/497)*(1/p - 1) \\\n            * ((tau_negative_tc**3)/6 + (tau_negative_tc**9)/135 + (tau_negative_tc**15)/600)\n                              )\n        # factor when tau < 1 and tc > 0\n        sub_tau_pos_tc = 1 - (1/A) * ((79/(140*p))*(tau_positive_tc**(-1)) + (474/497)*(1/p - 1) \\\n            * ((tau_positive_tc**3)/6 + (tau_positive_tc**9)/135 + (tau_positive_tc**15)/600)\n                              )\n        # factor when tau >= 1 and tc > 0\n        super_tau_pos_tc = -(1/A) * ((tau_positive_tc**-5)/10 + (tau_positive_tc**-15)/315 + (tau_positive_tc**-25)/1500)\n        # factor when tau >= 1 and tc < 0\n        super_tau_neg_tc = -(1/A) * ((tau_negative_tc**-5)/10 + (tau_negative_tc**-15)/315 + (tau_negative_tc**-25)/1500)\n\n        # This is an optimization to reduce the complexity of the compile-time expression\n        expr_cond_pairs = [(sub_tau_neg_tc, curie_temp/afm_factor > v.T),\n                           (sub_tau_pos_tc, curie_temp > v.T),\n                           (super_tau_pos_tc, And(curie_temp < v.T, curie_temp > 0)),\n                           (super_tau_neg_tc, And(curie_temp/afm_factor < v.T, curie_temp < 0)),\n                           (0, True)\n                           ]\n        g_term = Piecewise(*expr_cond_pairs)\n\n        return v.R * v.T * log(beta+1) * \\\n            g_term / site_ratio_normalization"
        },
        {
            "name": "xiong_magnetic_energy",
            "content": "\n    def xiong_magnetic_energy(self, dbe):\n        \n        #Return the energy from magnetic ordering in symbolic form.\n        #The approach follows W. Xiong et al, Calphad, 2012.\n        \n        phase = dbe.phases[self.phase_name]\n        param_search = dbe.search\n        self.TC = self.curie_temperature = S.Zero\n        if 'ihj_magnetic_structure_factor' not in phase.model_hints:\n            return S.Zero\n        if 'ihj_magnetic_afm_factor' not in phase.model_hints:\n            return S.Zero\n\n        site_ratio_normalization = self._site_ratio_normalization\n        # define basic variables\n        afm_factor = phase.model_hints['ihj_magnetic_afm_factor']\n\n        if afm_factor != 0:\n            raise ValueError('Xiong model called with nonzero AFM / Weiss factor')\n\n        nt_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'NT') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n\n        bm_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'BMAGN') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n        tc_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'TC') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n\n        mean_magnetic_moment = \\\n            self.redlich_kister_sum(phase, param_search, bm_param_query)\n        beta = mean_magnetic_moment\n\n        curie_temp = \\\n            self.redlich_kister_sum(phase, param_search, tc_param_query)\n        neel_temp = \\\n            self.redlich_kister_sum(phase, param_search, nt_param_query)\n\n        self.TC = self.curie_temperature = self.symbol_replace(curie_temp, self._symbols)\n        self.NT = self.neel_temperature = self.symbol_replace(neel_temp, self._symbols)\n        self.BMAG = self.beta = self.symbol_replace(beta, self._symbols)\n\n        tau_curie = v.T / curie_temp\n        tau_curie = tau_curie.xreplace({zoo: 1.0e10})\n        tau_neel = v.T / neel_temp\n        tau_neel = tau_neel.xreplace({zoo: 1.0e10})\n\n        # define model parameters\n        p = phase.model_hints['ihj_magnetic_structure_factor']\n        D = 0.33471979 + 0.49649686*(1/p - 1)\n        sub_tau_curie = 1 - (1/D) * ((0.38438376/p)*(tau_curie**(-1)) + 0.63570895*(1/p - 1) \\\n            * ((tau_curie**3)/6 + (tau_curie**9)/135 + (tau_curie**15)/600) + (tau_curie**21)/1617\n                              )\n        sub_tau_neel = 1 - (1/D) * ((0.38438376/p)*(tau_neel**(-1)) + 0.63570895*(1/p - 1) \\\n            * ((tau_neel**3)/6 + (tau_neel**9)/135 + (tau_neel**15)/600) + (tau_neel**21)/1617\n                              )\n        super_tau_curie = -(1/D) * ((tau_curie**-7)/21 + (tau_curie**-21)/630 + (tau_curie**-35)/2975 + (tau_curie**-49)/8232)\n        super_tau_neel = -(1/D) * ((tau_neel**-7)/21 + (tau_neel**-21)/630 + (tau_neel**-35)/2975 + (tau_neel**-49)/8232)\n\n        expr_cond_pairs_curie = [(0, tau_curie <= 0),\n                                 (super_tau_curie, tau_curie > 1),\n                                 (sub_tau_curie, True)\n                                ]\n        expr_cond_pairs_neel = [(0, tau_neel <= 0),\n                                (super_tau_neel, tau_neel > 1),\n                                (sub_tau_neel, True)\n                               ]\n        g_term = Piecewise(*expr_cond_pairs_curie) + Piecewise(*expr_cond_pairs_neel)\n\n        return v.R * v.T * log(beta+1) * \\\n            g_term / site_ratio_normalization"
        },
        {
            "name": "twostate_energy",
            "content": "\n    def twostate_energy(self, dbe):\n        \n        #Return the energy from liquid-amorphous two-state model.\n        \n        phase = dbe.phases[self.phase_name]\n        param_search = dbe.search\n        site_ratio_normalization = self._site_ratio_normalization\n        gd_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'GD') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n        gd = self.redlich_kister_sum(phase, param_search, gd_param_query)\n        if gd == S.Zero:\n            return S.Zero\n        return -v.R * v.T * log(1 + exp(-gd / (v.R * v.T))) / site_ratio_normalization"
        },
        {
            "name": "einstein_energy",
            "content": "\n    def einstein_energy(self, dbe):\n        \n        #Return the energy based on the Einstein model.\n        #Note that THETA parameters are actually LN(THETA).\n        #All Redlich-Kister summation is done in log-space,\n        #then exp() is called on the result.\n        \n        phase = dbe.phases[self.phase_name]\n        param_search = dbe.search\n        theta_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'THETA') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n        lntheta = self.redlich_kister_sum(phase, param_search, theta_param_query)\n        theta = exp(lntheta)\n        if lntheta != 0:\n            result = 1.5*v.R*theta + 3*v.R*v.T*log(1-exp(-theta/v.T))\n        else:\n            result = 0\n        return result / self._site_ratio_normalization"
        },
        {
            "name": "_quasi_mole_fraction",
            "content": "\n    def _quasi_mole_fraction(species_name, phase_name, constituent_array,\n                             site_ratios,\n                             substitutional_sublattice_idxs,\n                             ):\n        \n        #Return an abstract syntax tree of the quasi mole fraction of the\n        #given species as a function of this phases's constituent site fractions.\n\n        #These mole fractions are \"quasi\" mole fractions because\n\n        #1. Vacancies are treated as regular species - they have mole fractions\n        #   defined and the site fraction of vacancies are not used to normalize\n        #   the mole fractions of the real constituents by the 1 - y_{VA} factor.\n        #2. The mole fractions are only computed over the sublattices that\n        #   participate in the ordering/disordering. Species in non-ordering\n        #   (\"interstitial\") sublattices do not contribute to the mole fractions\n        #   that replace the site fractions.\n\n        #These constraints ensures that the ordering energy goes to zero when the\n        #substitutional sublattice is disordered, regardless of the occupancy of\n        #the interstitial sublattice.\n        \n\n        # Normalize site ratios\n        site_ratio_normalization = 0\n        numerator = S.Zero\n        for idx, sublattice in enumerate(constituent_array):\n            # only count species from substitutional sublattices\n            if idx not in substitutional_sublattice_idxs:\n                continue\n            if species_name in list(sublattice):\n                site_ratio_normalization += site_ratios[idx]\n                numerator += site_ratios[idx] * \\\n                    v.SiteFraction(phase_name, idx, species_name)\n\n        if site_ratio_normalization == 0 and species_name.name == 'VA':\n            return 1\n\n        if site_ratio_normalization == 0:\n            raise ValueError(\n                f'Couldn\\'t find {species_name} in a substitutional sublattice '\n                f'(indices: {substitutional_sublattice_idxs}) '\n                f'of the constituents {constituent_array}'\n                )\n\n        return numerator / site_ratio_normalization"
        },
        {
            "name": "_partitioned_expr",
            "content": "\n    def _partitioned_expr(disord_expr, ord_expr, disordered_mole_fraction_dict, ordered_mole_fraction_dict):\n        #Return the expression from adding the disordered part and ordering part\n\n        #Given expressions E^{dis}(y^{dis}_i) and E^{ord}(y^{ord}_i), return:\n\n        #    E^{dis}(x^{ord}_i) + (E^{ord}(y^{ord}_i) - E^{ord}(y^{ord}_i = x^{ord}_i))\n\n        #where:\n\n        #* y^{dis}_i are the site fractions of the disordered phase\n        #* y^{ord}_i are the site fractions of the ordered phase\n        #* x^{ord}_i are the quasi mole fractions of the ordered phase (in terms\n        #     of the ordered phase site fractions)\n\n        disord_expr = disord_expr.xreplace(disordered_mole_fraction_dict)\n        ordering_expr = ord_expr - ord_expr.xreplace(ordered_mole_fraction_dict)\n        return disord_expr + ordering_expr"
        },
        {
            "name": "atomic_ordering_energy",
            "content": "\n    def atomic_ordering_energy(self, dbe):\n\n        phase = dbe.phases[self.phase_name]\n        ordered_phase_name = phase.model_hints.get('ordered_phase', None)\n        disordered_phase_name = phase.model_hints.get('disordered_phase', None)\n        if phase.name != ordered_phase_name:\n            return S.Zero\n        ordered_phase = dbe.phases[ordered_phase_name]\n        constituents = [sorted(set(c).intersection(self.components)) for c in ordered_phase.constituents]\n        disordered_phase = dbe.phases[disordered_phase_name]\n        disordered_model = self.__class__(dbe, sorted(self.components), disordered_phase_name)\n\n        # Get substitutional sublattice indices (for the ordered phase) and\n        # validate that the number of interstitial sublattices is consistent\n        # with the disordered phase.\n        # Assumes first sublattice of the disordered phase is the sublattice\n        # that can be come ordered:\n        disordered_subl_constituents = disordered_phase.constituents[0]\n        ordered_constituents = ordered_phase.constituents\n        substitutional_sublattice_idxs = []\n        for idx, subl_constituents in enumerate(ordered_constituents):\n            # Assumes that the ordered phase sublattice describes the ordering\n            # if it has exactly the same constituents. Could be a source of\n            # false positives if any interstitial sublattices have the same\n            # constituents as the disordered sublattice, but there's not an\n            # explicit way to specify which sublattices are ordering. We try to\n            # compensate for this assumption by validating (next).\n            if len(disordered_subl_constituents.symmetric_difference(subl_constituents)) == 0:\n                substitutional_sublattice_idxs.append(idx)\n        # validate\n        num_substitutional_sublattice_idxs = len(substitutional_sublattice_idxs)\n        num_ordered_interstitial_subls = len(ordered_phase.sublattices) - num_substitutional_sublattice_idxs\n        num_disordered_interstitial_subls = len(disordered_phase.sublattices) - 1\n        if num_ordered_interstitial_subls != num_disordered_interstitial_subls:\n            raise ValueError(\n                f'Number of interstitial sublattices for the disordered phase '\n                f'({num_disordered_interstitial_subls}) and the ordered phase '\n                f'({num_ordered_interstitial_subls}) do not match. Got '\n                f'substitutional sublattice indices of {substitutional_sublattice_idxs}.'\n                )\n        # We also validate that no physical properties have ordered\n        # contributions because the underlying physical property needs to\n        # paritioned and substituted for the physical property in the disordered\n        # expression. This can be safely removed when partitioned\n        # physical properties are correctly substituted into the disordered\n        # energy.\n        for contrib, value in self.models.items():\n            # To handle ordering in user-defined subclasses, we assume that all properties\n            # that are not reference, ideal, or excess are physical contributions.\n            if contrib in ('ref', 'idmix', 'xsmix'):\n                continue\n            if value != S.Zero:\n                warnings.warn(\n                    f\"The order-disorder model for \\\"{self.phase_name}\\\" has a contribution from \"\n                    f\"the physical property model `{dict(self.contributions)[contrib]}`. \"\n                    f\"Partitioned physical properties are not correctly substituted into the \"\n                    f\"disordered part of the energy. THE GIBBS ENERGY CALCULATED FOR THIS PHASE \"\n                    f\"MAY BE INCORRECT. Please see the discussion in \"\n                    f\"https://github.com/pycalphad/pycalphad/pull/311 for more details.\"\n                    )\n\n        # Save all of the ordered energy contributions\n        # Needs to extract a copy of self.models.values because the values will\n        # be updated to the disordered energy contributions later\n        ordered_energy = Add(*list(self.models.values()))\n\n        # Compute the molefraction_dict, which will map ordered phase site\n        # fractions to the quasi mole fractions representing the disordered state\n        molefraction_dict = {}\n        ordered_sitefracs = [x for x in ordered_energy.free_symbols if isinstance(x, v.SiteFraction)]\n        for sitefrac in ordered_sitefracs:\n            if sitefrac.sublattice_index in substitutional_sublattice_idxs:\n                molefraction_dict[sitefrac] = \\\n                    self._quasi_mole_fraction(sitefrac.species,\n                                              ordered_phase_name,\n                                              constituents,\n                                              ordered_phase.sublattices,\n                                              substitutional_sublattice_idxs,\n                                              )\n\n        # Compute the variable_rename_dict, which will map disordered phase site\n        # fractions to the quasi mole fractions representing the disordered state\n        variable_rename_dict = {}\n        disordered_sitefracs = [x for x in disordered_model.energy.free_symbols if isinstance(x, v.SiteFraction)]\n        for atom in disordered_sitefracs:\n            if atom.sublattice_index == 0:  # only the first sublattice is substitutional\n                variable_rename_dict[atom] = \\\n                    self._quasi_mole_fraction(atom.species,\n                                              ordered_phase_name,\n                                              constituents,\n                                              ordered_phase.sublattices,\n                                              substitutional_sublattice_idxs,\n                                              )\n\n            else:\n                shifted_subl_index = atom.sublattice_index + num_substitutional_sublattice_idxs - 1\n                variable_rename_dict[atom] = \\\n                    v.SiteFraction(ordered_phase_name, shifted_subl_index, atom.species)\n\n        # 1: Compute the ordering energy\n        # Step 2 will put the disordered parts into the correct model\n        # contributions. There's no technical reason for doing it this way\n        # compared to setting the AST to the _partitioned_expr for the total\n        # energy - this is more for bookkeeping of the model contributions.\n        ordering_energy = self._partitioned_expr(S.Zero, ordered_energy, {}, molefraction_dict)\n\n        # 2: Replace the ordered energy contributions with the disordered contributions\n        self.models.clear()\n        for name, value in disordered_model.models.items():\n            self.models[name] = value.xreplace(variable_rename_dict)\n\n        # 3: Handle physical properties, these also are contributed to by the\n        # disordered phase *and* an \"ordering\" contribution. For now, we only\n        # handle the magnetic parameters, since the other parameters are not\n        # stored as properties (e.g. Einstein THETA).\n        # TODO: Note that these do not affect the Gibbs energy expression!\n        # The disordered model's energetic contribution from physical\n        # properties needs to use the partitioned property in the disordered\n        # energy contribution. This is not possible at the time of writing.\n        self.TC = self.curie_temperature = self._partitioned_expr(disordered_model.TC, self.TC, variable_rename_dict, molefraction_dict)\n        self.BMAG = self.beta = self._partitioned_expr(disordered_model.BMAG, self.BMAG, variable_rename_dict, molefraction_dict)\n        self.NT = self.neel_temperature = self._partitioned_expr(disordered_model.NT, self.NT, variable_rename_dict, molefraction_dict)\n\n        return ordering_energy"
        },
        {
            "name": "shift_reference_state",
            "content": "\n    def shift_reference_state(self, reference_states, dbe, contrib_mods=None, output=('GM', 'HM', 'SM', 'CPM'), fmt_str=\"{}R\"):\n        \n        #Add new attributes for calculating properties w.r.t. an arbitrary pure element reference state.\n\n        #Parameters\n        #----------\n        #reference_states : Iterable of ReferenceState\n        #    Pure element ReferenceState objects. Must include all the pure\n        #    elements defined in the current model.\n        #dbe : Database\n        #    Database containing the relevant parameters.\n        #output : Iterable, optional\n        #    Parameters to subtract the ReferenceState from, defaults to ('GM', 'HM', 'SM', 'CPM').\n        #contrib_mods : Mapping, optional\n        #    Map of {model contribution: new value}. Used to adjust the pure\n        #    reference model contributions at the time this is called, since\n        #    the `models` attribute of the pure element references are\n        #    effectively static after calling this method.\n        #fmt_str : str, optional\n        #    String that will be formatted with the `output` parameter name.\n        #    Defaults to \"{}R\", e.g. the transformation of 'GM' -> 'GMR'\n\n        \n        # Error checking\n        # We ignore the case that the ref states are overspecified (same ref states can be used in different models w/ different active pure elements)\n        model_pure_elements = set(get_pure_elements(dbe, self.components))\n        refstate_pure_elements_list = get_pure_elements(dbe, [r.species for r in reference_states])\n        refstate_pure_elements = set(refstate_pure_elements_list)\n        if len(refstate_pure_elements_list) != len(refstate_pure_elements):\n            raise DofError(\"Multiple ReferenceState objects exist for at least one pure element: {}\".format(refstate_pure_elements_list))\n        if not refstate_pure_elements.issuperset(model_pure_elements):\n            raise DofError(\"Non-existent ReferenceState for pure components {} in {} for {}\".format(model_pure_elements.difference(refstate_pure_elements), self, self.phase_name))\n\n        contrib_mods = contrib_mods or {}\n\n        def _pure_element_test(constituent_array):\n            all_comps = set()\n            for sublattice in constituent_array:\n                if len(sublattice) != 1:\n                    return False\n                all_comps.add(sublattice[0].name)\n            pure_els = all_comps.intersection(model_pure_elements)\n            return len(pure_els) == 1\n\n        # Remove interactions from a copy of the Database, avoids any element/VA interactions.\n        endmember_only_dbe = copy.deepcopy(dbe)\n        endmember_only_dbe._parameters.remove(~where('constituent_array').test(_pure_element_test))\n        reference_dict = {out: [] for out in output}  # output: terms list\n        for ref_state in reference_states:\n            if ref_state.species not in self.components:\n                continue\n            mod_pure = self.__class__(endmember_only_dbe, [ref_state.species, v.Species('VA')], ref_state.phase_name, parameters=self._parameters_arg)\n            # apply the modifications to the Models\n            for contrib, new_val in contrib_mods.items():\n                mod_pure.models[contrib] = new_val\n            # set all the free site fractions to one, this should effectively delete any mixing terms spuriously added, e.g. idmix\n            site_frac_subs = {sf: 1 for sf in mod_pure.ast.free_symbols if isinstance(sf, v.SiteFraction)}\n            for mod_key, mod_val in mod_pure.models.items():\n                mod_pure.models[mod_key] = self.symbol_replace(mod_val, site_frac_subs)\n            moles = self.moles(ref_state.species)\n            # get the output property of interest, substitute the fixed state variables (e.g. T=298.15) and add the pure element moles weighted term to the list of terms\n            # substitution of fixed state variables has to happen after getting the attribute in case there are any derivatives involving that state variable\n            for out in reference_dict.keys():\n                mod_out = self.symbol_replace(getattr(mod_pure, out), ref_state.fixed_statevars)\n                reference_dict[out].append(mod_out*moles)\n\n        # set the attribute on the class\n        for out, terms in reference_dict.items():\n            reference_contrib = Add(*terms)\n            referenced_value = getattr(self, out) - reference_contrib\n            setattr(self, fmt_str.format(out), referenced_value)"
        },
        {
            "name": "volume_energy",
            "content": "\n    def volume_energy(self, dbe):\n    \n        #Return the volumetric contribution in symbolic form. Follows the approach by Lu, Selleby, and Sundman [1].\n\n        #Parameters\n        #----------\n        #dbe : Database\n        #    Database containing the relevant parameters.\n        \n\n\n        phase = dbe.phases[self.phase_name]\n        param_search = dbe.search\n\n        V0_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'V0') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n\n        VA_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'VA') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n\n        VK_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'VK') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n\n        VC_param_query = (\n            (where('phase_name') == phase.name) & \\\n            (where('parameter_type') == 'VC') & \\\n            (where('constituent_array').test(self._array_validity))\n        )\n\n        V0 = self.redlich_kister_sum(phase, param_search, V0_param_query)\n        VA = self.redlich_kister_sum(phase, param_search, VA_param_query)\n        VK = self.redlich_kister_sum(phase, param_search, VK_param_query)\n        VC = self.redlich_kister_sum(phase, param_search, VC_param_query)\n\n        # nonmagnetic contribution to volume\n        V_p0 = V0*exp(VA)\n\n        # magnetic contribution to volume\n        G_mag = self.models.get('mag')\n        V_mag = G_mag.diff(v.P)\n\n        self.MV = self.molar_volume = V_p0 + V_mag\n        volume_energy = S.Zero\n\n        if VK == 0:\n            volume_energy = V_p0*(v.P-101325)\n        else:\n            warnings.warn(\n                    f\"The database for \\\"{self.phase_name}\\\" contains a term for the isothermal compressibility\"\n                    f\"however the pressure dependence has not been fully incorporated into the molar volume or\"\n                    f\"Gibbs free energy models. THE GIBBS ENERGY AND MOLAR VOLUME CALCULATIONS MAY BE INCORRECT.\")\n\n        return volume_energy"
        },
        {
            "name": "_pure_element_test",
            "content": "\n    def _pure_element_test(constituent_array):\n            all_comps = set()\n            for sublattice in constituent_array:\n                if len(sublattice) != 1:\n                    return False\n                all_comps.add(sublattice[0].name)\n            pure_els = all_comps.intersection(model_pure_elements)\n            return len(pure_els) == 1"
        },
        {
            "name": "quantities",
            "content": "\n    DOO = degree_of_ordering\n\n    # Can be defined as a list of pre-computed first derivatives\n    gradient = None\n\n    # Note: In order-disorder phases, TC will always be the *disordered* value of TC\n    curie_temperature = TC = S.Zero\n    beta = BMAG = S.Zero\n    neel_temperature = NT = S.Zero\n\n    #pylint: disable=C0103\n    # These are standard abbreviations from Thermo-Calc for these quantities\n    energy = GM = property(lambda self: self.ast)\n    formulaenergy = G = property(lambda self: self.ast * self._site_ratio_normalization)\n    entropy = SM = property(lambda self: -self.GM.diff(v.T))\n    enthalpy = HM = property(lambda self: self.GM - v.T*self.GM.diff(v.T))\n    heat_capacity = CPM = property(lambda self: -v.T*self.GM.diff(v.T, v.T))\n    #pylint: enable=C0103\n    mixing_energy = GM_MIX = property(lambda self: self.GM - self.endmember_reference_model.GM)\n    mixing_enthalpy = HM_MIX = property(lambda self: self.GM_MIX - v.T*self.GM_MIX.diff(v.T))\n    mixing_entropy = SM_MIX = property(lambda self: -self.GM_MIX.diff(v.T))\n    mixing_heat_capacity = CPM_MIX = property(lambda self: -v.T*self.GM_MIX.diff(v.T, v.T))\n"
        }
    ]
}